/**
 * Copyright (c) 2019 Vernier Software. All rights reserved.
 * This code may only be used under the GPL-3 license found at
 * https://raw.githubusercontent.com/VernierST/godirect-js/master/LICENSE
 */

const HEADER=new Uint8Array([88,0,0,0]),INIT=new Uint8Array([26,165,74,6,73,7,72,8,71,9,70,10,69,11,68,12,67,13,66,14,65]),START_MEASUREMENTS=new Uint8Array([24,255,1,0,0,0,0,0,0,0,0,0,0,0,0]),STOP_MEASUREMENTS=new Uint8Array([25,255,0,255,255,255,255]),SET_MEASUREMENT_PERIOD=new Uint8Array([27,255,0,0,0,0,0,0,0,0,0]),DISCONNECT=new Uint8Array([84]),GET_INFO=new Uint8Array([85]),GET_STATUS=new Uint8Array([16]),GET_SENSOR_IDS=new Uint8Array([81]),GET_SENSOR_INFO=new Uint8Array([80,0]),GET_DEFAULT_SENSORS_MASK=new Uint8Array([86]),commands={HEADER:HEADER,INIT:INIT,DISCONNECT:DISCONNECT,START_MEASUREMENTS:START_MEASUREMENTS,STOP_MEASUREMENTS:STOP_MEASUREMENTS,SET_MEASUREMENT_PERIOD:SET_MEASUREMENT_PERIOD,GET_INFO:GET_INFO,GET_STATUS:GET_STATUS,GET_SENSOR_IDS:GET_SENSOR_IDS,GET_SENSOR_INFO:GET_SENSOR_INFO,GET_DEFAULT_SENSORS_MASK:GET_DEFAULT_SENSORS_MASK},NORMAL_REAL32=6,WIDE_REAL32=7,APERIODIC_REAL32=10,SINGLE_CHANNEL_REAL32=8,SINGLE_CHANNEL_INT32=9,APERIODIC_INT32=11,START_TIME=12,DROPPED=13,PERIOD=14,measurementType={NORMAL_REAL32:6,WIDE_REAL32:7,APERIODIC_REAL32:10,SINGLE_CHANNEL_REAL32:8,SINGLE_CHANNEL_INT32:9,APERIODIC_INT32:11,START_TIME:12,DROPPED:13,PERIOD:14},MEASUREMENT=32,responseType={MEASUREMENT:32},isFunction=e=>"function"==typeof e||!1,nonZero=e=>0!==e;class EventEmitter{constructor(){this._listenerMap=new Map}on(e,t){this._listenerMap.has(e)||this._listenerMap.set(e,[]),this._listenerMap.get(e).push(t)}off(e,t){const n=this._listenerMap.get(e);if(n&&n.length){const s=n.reduce((e,n,s)=>{return isFunction(n)&&n===t?e=s:e},-1);if(s>-1)return n.splice(s,1),this._listenerMap.set(e,n),!0}return!1}unbind(){this._listenerMap.clear()}emit(e,...t){const n=this._listenerMap.get(e);return!(!n||!n.length)&&(n.forEach(e=>{e(...t)}),!0)}}const log=function(){},dir=function(){};function bufferToHex(e){return Array.from(new Uint8Array(e)).map(e=>e.toString(16).padStart(2,"0")).join(" ")}function appendBuffer(e,t){const n=new Uint8Array(e.byteLength+t.byteLength);return n.set(new Uint8Array(e),0),n.set(new Uint8Array(t),e.byteLength),n.buffer}class MeasurementInfo{constructor(e={}){this.type=e.type,this.mode=e.mode,this.minValue=e.minValue,this.maxValue=e.maxValue,this.uncertainty=e.uncertainty,this.minPeriod=e.minPeriod,this.maxPeriod=e.maxPeriod,this.typicalPeriod=e.typicalPeriod,this.granularity=e.granularity}}class SensorSpecs{constructor(e={}){this.number=e.number,this.name=e.name,this.unit=e.unit,this.id=e.id,this.mutalExclusionMask=e.mutalExclusionMask,this.measurementInfo=e.measurementInfo}}class Sensor extends EventEmitter{constructor(e){super(),this.number=e.number,this.name=e.name,this.unit=e.unit,this.specs=e,this.enabled=!1,this.values=[],this.value=null}clear(){this.value=null,this.values=[]}setValue(e,t){this.value=e,t&&this.values.push(this.value),this.emit("value-changed",this)}setEnabled(e){this.enabled!==e&&(this.enabled=e,this.emit("state-changed",this))}}class Device extends EventEmitter{constructor(e){super(),this.device=e,this.sensors=[],this.opened=!1,this.rollingCounter=0,this.collecting=!1,this.measurementPeriod=10,this.response=null,this.remainingResponseLength=0,this.defaultSensorsMask=0,this.keepValues=!0,this.minMeasurementPeriod=10,this.serialNumber="",this.orderCode="",this.name=""}async getBatteryLevel(){return(await this._getStatus()).battery}async getChargingState(){return(await this._getStatus()).chargingStatus}async open(e=!1){try{await this._connect(),await this._init(),await this._getStatus(),await this._getDeviceInfo(),await this._getDefaultSensorsMask(),await this._getAvailableSensors(),this._onOpened(),e&&this.start()}catch(e){console.error(e)}}async close(){return await this._stopMeasurements(),await this._sendCommand(commands.DISCONNECT),this._disconnect()}enableDefaultSensors(){let e=1;for(let t=0;t<32;++t){if((this.defaultSensorsMask&e)===e){const e=this.getSensor(t);e&&e.setEnabled(!0)}e<<=1}}start(e=null){let t=this.sensors.filter(e=>e.enabled);0===t.length&&(this.enableDefaultSensors(),t=this.sensors.filter(e=>e.enabled)),t.forEach(e=>e.clear()),e&&(this.measurementPeriod=e),this._startMeasurements()}stop(){this._stopMeasurements()}getSensor(e){return this.sensors.find(t=>t.number===e)}async _connect(){return this.device.setup({onClosed:()=>this._onClosed(),onResponse:e=>this._handleResponse(e)})}async _disconnect(){return this.device.close()}_init(){return this.collecting=!1,this.rollingCounter=255,this.writeQueue=[],this._sendCommand(commands.INIT)}_handleResponse(e){if(log(`command notified: ${bufferToHex(e.buffer)}`),this.remainingResponseLegnth>0){if(this.remainingResponseLegnth-=e.buffer.byteLength,this.response=new DataView(appendBuffer(this.response.buffer,e.buffer.slice(0))),this.remainingResponseLegnth>0)return}else this.response=e;const t=this.response.getUint8(1);if(t>this.response.buffer.byteLength)this.remainingResponseLegnth=t-this.response.buffer.byteLength;else switch(log(`handle command: ${bufferToHex(this.response.buffer)}`),this.response.getUint8(0)){case responseType.MEASUREMENT:this._processMeasurements(this.response);break;default:{const e=this.response.getUint8(4),t=this.response.getUint8(5),n=new DataView(this.response.buffer,6);this._resolveWriteCommand(e,t,n),this.remainingResponseLegnth=0,this.response=null;break}}}_getSensorsWithMask(e){const t=[];let n=1;for(let s=0;s<32;++s){if((e&n)===n){const n=this.getSensor(s);n&&(t.push(n),log(`available: [${e}] ${t[t.length-1].number}`))}n<<=1}return t}_processMeasurements(e){let t=[],n=!0,s=0,i=0;const r=e.getUint8(4);switch(r){case measurementType.NORMAL_REAL32:t=this._getSensorsWithMask(e.getUint16(5,!0)),s=e.getUint8(7,!0),i=9;break;case measurementType.WIDE_REAL32:t=this._getSensorsWithMask(e.getUint32(5,!0)),s=e.getUint8(9,!0),i=11;break;case measurementType.APERIODIC_REAL32:case measurementType.SINGLE_CHANNEL_REAL32:t[0]=this.getSensor(e.getUint8(6)),s=e.getUint8(7,!0),i=8;break;case measurementType.APERIODIC_INT32:case measurementType.SINGLE_CHANNEL_INT32:t[0]=this.getSensor(e.getUint8(6)),s=e.getUint8(7,!0),i=8,n=!1;break;case measurementType.START_TIME:case measurementType.DROPPED:case measurementType.PERIOD:log(`Purposely Ignoring packet type: ${r}`);break;default:log(`Unknown packet type: ${r}`)}for(let r=0;r<s;++r)for(let s=0;s<t.length;++s)n?t[s].setValue(e.getFloat32(i,!0),this.keepValues):t[s].setValue(e.getInt32(i,!0),this.keepValues),i+=4}_resolveWriteCommand(e,t,n){const s=this.writeQueue.find(n=>n.command===e&&n.rollingCounter===t);s&&(s.resolve(n),this.writeQueue=this.writeQueue.filter(e=>e!==s))}_onOpened(){log("opened"),this.opened=!0,this.emit("device-opened")}_onClosed(){log("closed"),this.opened=!1,this.emit("device-closed")}_decRollingCounter(){return this.rollingCounter-=1,this.rollingCounter}_calculateChecksum(e){const t=e[1];let n=-1*e[3];for(let s=0;s<t;++s)n+=e[s],n&=255;return n<0||n>255?(log("Checksum failed!"),0):n}_sendCommand(e){const t=new Uint8Array(commands.HEADER.byteLength+e.byteLength);return t.set(new Uint8Array(commands.HEADER),0),t.set(new Uint8Array(e),commands.HEADER.byteLength),t[1]=t.length,t[2]=this._decRollingCounter(),t[3]=this._calculateChecksum(t),this._queueWriteCommand(t,0,t.length)}async _writeCommand(e,t,n){let s;for(;n>0;)try{n>20?(s=e.subarray(t,t+20),n-=20,t+=20):(s=e.subarray(t,t+n),n=0),await this.device.writeCommand(s)}catch(e){log(`Write Failure: ${e}`)}}_queueWriteCommand(e,t,n){log(`command queued: ${bufferToHex(e)}`);const s=new Promise((t,n)=>{this.writeQueue.push({command:e[4],rollingCounter:e[2],resolve:t,reject:n}),setTimeout(()=>{this.writeQueue=this.writeQueue.filter(t=>t.command===e[4]&&t.rollingCounter!==e[2]),n(new Error(`write command timed out after 5s. Command: ${e[4].toString(16)} Rolling Counter: ${e[2].toString(16)}`))},1e4)});return this._writeCommand(e,t,n),s}async _getStatus(){const e=await this._sendCommand(commands.GET_STATUS);return{masterFirmwareVersion:`${e.getUint8(2)}.${e.getUint8(3)}`,bleFirmwareVersion:`${e.getUint8(6)}.${e.getUint8(9)}`,battery:e.getUint8(10),chargingStatus:`${e.getUint8(11)}`}}async _getAvailableSensors(){await this._sendCommand(commands.GET_SENSOR_IDS).then(e=>{this.availableSensors=e.getUint32(0,!0),log(`Get Available Sensors Returned ${this.availableSensors}`)});let e=1;for(let t=0;t<31;++t)(this.availableSensors&e)===e&&await this._getSensorInfo(t),e<<=1}_getDefaultSensorsMask(){return this._sendCommand(commands.GET_DEFAULT_SENSORS_MASK).then(e=>{this.defaultSensorsMask=e.getUint32(0,!0),log("Default Sensors:"),dir(this)})}_getDeviceInfo(){return this._sendCommand(commands.GET_INFO).then(e=>{const t=new TextDecoder("utf-8");this.orderCode=t.decode(new Uint8Array(e.buffer,6,16).filter(nonZero)),this.serialNumber=t.decode(new Uint8Array(e.buffer,22,16).filter(nonZero)),this.name=t.decode(new Uint8Array(e.buffer,38,32).filter(nonZero)),log("Device Info:"),dir(this)})}async _getSensorInfo(e){const t=new Uint8Array(commands.GET_SENSOR_INFO);return t[1]=e,this._sendCommand(t).then(e=>{const t=e.getUint32(2,!0);if(t>0){const n=new TextDecoder("utf-8"),s=new MeasurementInfo({type:e.getUint8(6),mode:e.getUint8(7),minValue:e.getFloat64(108,!0),maxValue:e.getFloat64(116,!0),uncertainty:e.getFloat64(100,!0),minPeriod:e.getUint32(124,!0)/1e3,maxPeriod:((e.getUint32(132,!0)<<32)+e.getUint32(128,!0))/1e3,typicalPeriod:e.getUint32(136,!0)/1e3,granularity:e.getUint32(140,!0)/1e3}),i=new SensorSpecs({number:e.getUint8(0),name:n.decode(new Uint8Array(e.buffer,14,60).filter(nonZero)),unit:n.decode(new Uint8Array(e.buffer,74,32).filter(nonZero)),mutalExclusiveMask:e.getUint32(144,!0),measurementInfo:s,sensorId:t}),r=new Sensor(i);log("Get Sensor Info Returned"),dir(r),this.sensors.push(r),r.on("state-changed",()=>{log(`Sensor Restart: ${r.number}`),r.enabled&&(this.measurementPeriod=r.specs.measurementInfo.typicalPeriod,this.sensors.forEach(e=>{if(r.number!==e.number&&e.enabled){const t=1<<e.number;(t&r.specs.mutalExclusiveMask)===t?e.enabled=!1:e.specs.measurementInfo.typicalPeriod>this.measurementPeriod&&(this.measurementPeriod=e.specs.measurementInfo.typicalPeriod)}})),this._restartMeasurements()})}})}async _restartMeasurements(){const e=this.collecting;if(this.collecting)try{await this._stopMeasurements()}catch(e){console.error(e)}if(!this.collecting&&e)try{await this._startMeasurements()}catch(e){console.error(e)}}_setMeasurementPeriod(e){const t=new Uint8Array(commands.SET_MEASUREMENT_PERIOD),n=1e3*this.minMeasurementPeriod;return e<n&&(e=n),log(`MeasurementPeriod: ${e}`),t[3]=e>>0&255,t[4]=e>>8&255,t[5]=e>>16&255,t[6]=e>>24&255,this._sendCommand(t)}_getEnabledChannelMask(){let e=0;return this.sensors.filter(e=>e.enabled).forEach(t=>{e+=1<<t.number}),e}_startMeasurements(){return this._setMeasurementPeriod(1e3*this.measurementPeriod).then(()=>{const e=this._getEnabledChannelMask();log(`ChannelMask: ${e}`);const t=new Uint8Array(commands.START_MEASUREMENTS);return t[3]=e>>0&255,t[4]=e>>8&255,t[5]=e>>16&255,t[6]=e>>24&255,this._sendCommand(t).then(e=>{0===e.getUint8(0)&&(this.collecting=!0,this.emit("measurements-started"))})})}_stopMeasurements(){return this._sendCommand(commands.STOP_MEASUREMENTS).then(e=>{0===e.getUint8(0)&&(this.collecting=!1,this.emit("measurements-stopped"))})}}const SERVICE="d91714ef-28b9-4f91-ba16-f0d9a604f112",COMMAND_CHARACTERISTIC="f4bf14a6-c7d5-4b6d-8aa8-df1a7c83adcb",RESPONSE_CHARACTERISTIC="b41e6675-a329-40e0-aa01-44d2f444babe";class WebBluetoothDeviceAdapter{constructor(e){this.webBluetoothNativeDevice=e,this.deviceCommand=null,this.deviceResponse=null}get godirectAdapter(){return!0}async writeCommand(e){return this.deviceCommand.writeValue(e)}async setup({onClosed:e,onResponse:t}){this.webBluetoothNativeDevice.addEventListener("gattserverdisconnected",e);try{const e=await this.webBluetoothNativeDevice.gatt.connect(),n=await e.getPrimaryService(SERVICE);(await n.getCharacteristics()).forEach(e=>{switch(e.uuid){case COMMAND_CHARACTERISTIC:this.deviceCommand=e;break;case RESPONSE_CHARACTERISTIC:this.deviceResponse=e,this.deviceResponse.addEventListener("characteristicvaluechanged",e=>{const n=e.target.value;t(n)}),this.deviceResponse.startNotifications();break;default:log(`No case found for ${e.uuid}`)}})}catch(e){console.error(e)}if(!this.deviceCommand||!this.deviceResponse)throw new Error("Expected command and response characteristics not found.")}async close(){return this.webBluetoothNativeDevice.gatt.disconnect()}}const godirect={async createDevice(e,{open:t=!0,startMeasurements:n=!0}={}){let s=e;s.godirectAdapter||(s=new WebBluetoothDeviceAdapter(e));const i=new Device(s);if(t)try{await i.open(n)}catch(e){throw console.error(e),e}return i},async selectDevice(){if(!navigator.bluetooth)return Promise.reject(new Error("No Web Bluetooth support."));const e=await navigator.bluetooth.requestDevice({filters:[{namePrefix:"GDX"}],optionalServices:["d91714ef-28b9-4f91-ba16-f0d9a604f112"]});return godirect.createDevice(e)}};export default godirect;
